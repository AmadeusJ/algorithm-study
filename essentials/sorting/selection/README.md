# Selection Sort

선택 정렬(Selection Sort)은 리스트에서 **가장 작은(또는 큰) 값을 선택하여 정렬된 부분으로 이동시키는 방식**의 정렬 알고리즘입니다. 이 알고리즘이 "선택" 정렬이라 불리는 이유는 각 반복에서 정렬되지 않은 부분 중에서 가장 작은(또는 큰) 요소를 "선택"해서 정렬된 위치로 이동시키기 때문입니다.

### 선택 정렬의 동작 방식

1. 리스트의 첫 번째 요소부터 시작해, 남은 리스트 중에서 가장 작은 값을 찾습니다.
2. 찾은 값을 현재 위치에 있는 요소와 교환하여 정렬된 부분에 추가합니다.
3. 리스트의 다음 요소로 이동하여, 나머지 리스트 중에서 다시 가장 작은 값을 선택하고 교환합니다.
4. 이 과정을 리스트 끝까지 반복하여, 모든 요소가 정렬된 위치로 이동하면 정렬이 완료됩니다.

---

### 예시

리스트 `[5, 3, 8, 4, 2]`가 있다고 가정해 보겠습니다.

- 첫 번째 반복:
  - 리스트에서 가장 작은 값(2)을 찾습니다.
  - 첫 번째 위치(5)와 2를 교환 → `[2, 3, 8, 4, 5]`
  
- 두 번째 반복:
  - 나머지 부분 `[3, 8, 4, 5]`에서 가장 작은 값(3)을 찾습니다.
  - 현재 위치가 3이므로 교환할 필요 없음 → `[2, 3, 8, 4, 5]`
  
- 세 번째 반복:
  - 나머지 부분 `[8, 4, 5]`에서 가장 작은 값(4)을 찾습니다.
  - 현재 위치에 있는 8과 4를 교환 → `[2, 3, 4, 8, 5]`

- 네 번째 반복:
  - 나머지 부분 `[8, 5]`에서 가장 작은 값(5)을 찾습니다.
  - 현재 위치에 있는 8과 5를 교환 → `[2, 3, 4, 5, 8]`

이제 리스트가 모두 정렬되었습니다.

---

### 시간 복잡도

- **평균 시간 복잡도**: \(O(n^2)\)
- **최악 시간 복잡도**: \(O(n^2)\)
- **최선 시간 복잡도**: \(O(n^2)\) (이미 정렬된 경우에도 동일)

선택 정렬은 버블 정렬과 동일하게 \(O(n^2)\)의 시간 복잡도를 가지지만, 정렬하는 과정에서 비교 횟수를 줄일 수는 없습니다.

---

### 선택 정렬의 특징

- 선택 정렬은 **제자리 정렬(in-place sort)**입니다. 즉, 추가적인 메모리 공간을 거의 사용하지 않으며, 원래 배열에서 값들을 교환해 나가면서 정렬합니다.
- **비교 횟수**가 많아 \(O(n^2)\)이기 때문에 효율적이지 않습니다.
- 작은 배열에서는 단순하고 구현이 쉬워서 유용할 수 있지만, 큰 배열에서는 효율성이 떨어져 실무에서 잘 사용되지 않습니다.

선택 정렬은 간단한 알고리즘이지만, 성능이 좋지 않기 때문에 학습용으로 주로 사용됩니다.