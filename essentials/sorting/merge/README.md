병합 정렬(Merge Sort)은 **분할 정복(Divide and Conquer)** 알고리즘의 대표적인 예로, 리스트를 반으로 나누어 정렬한 후 다시 병합하는 방식으로 작동합니다. 병합 정렬은 **항상 \(O(n \log n)\)**의 시간 복잡도를 보장하며, **안정 정렬(Stable Sort)**이기 때문에 중복된 요소의 상대적 순서를 유지합니다. 

### 병합 정렬의 동작 방식

병합 정렬은 다음과 같은 단계를 통해 리스트를 정렬합니다.

1. **분할(Divide)**:
   - 리스트의 크기가 1 이하가 될 때까지 리스트를 반으로 나눕니다. (재귀적으로 호출)
   
2. **정복(Conquer)**:
   - 각 부분 리스트가 크기 1이 되면, 이들은 이미 정렬된 상태입니다.
   
3. **병합(Merge)**:
   - 분할된 리스트를 정렬하면서 하나의 리스트로 병합합니다.
   - 병합 과정에서 각 요소를 비교하여 작은 값부터 순서대로 새로운 리스트에 추가합니다.

### 병합 정렬의 예시

리스트 `[38, 27, 43, 3, 9, 82, 10]`을 병합 정렬로 정렬하는 과정을 예시로 살펴보겠습니다.

1. **분할 과정**:
   - `[38, 27, 43, 3, 9, 82, 10]` → `[38, 27, 43, 3]`와 `[9, 82, 10]`으로 나눕니다.
   - `[38, 27, 43, 3]` → `[38, 27]`과 `[43, 3]`으로 나눕니다.
   - `[9, 82, 10]` → `[9]`과 `[82, 10]`으로 나눕니다.
   - 계속해서 리스트를 쪼개어 크기가 1인 부분 리스트가 되도록 나눕니다.

2. **병합 과정**:
   - `[38]`과 `[27]`을 병합하여 `[27, 38]`으로 정렬합니다.
   - `[43]`과 `[3]`을 병합하여 `[3, 43]`으로 정렬합니다.
   - `[27, 38]`과 `[3, 43]`을 병합하여 `[3, 27, 38, 43]`으로 정렬합니다.
   - `[82]`과 `[10]`을 병합하여 `[10, 82]`로 정렬합니다.
   - `[9]`과 `[10, 82]`을 병합하여 `[9, 10, 82]`로 정렬합니다.
   - 최종적으로 `[3, 27, 38, 43]`과 `[9, 10, 82]`를 병합하여 `[3, 9, 10, 27, 38, 43, 82]`로 정렬된 리스트를 완성합니다.

---

### 병합 정렬의 시간 복잡도

- **시간 복잡도**: \(O(n \log n)\) – 병합 정렬은 항상 동일한 시간 복잡도를 보장합니다.
  - 리스트를 반으로 나누는 데 \(O(\log n)\), 나눈 리스트를 병합하는 데 \(O(n)\)의 시간이 걸리므로, 전체 시간 복잡도는 \(O(n \log n)\)입니다.
  
- **공간 복잡도**: \(O(n)\) – 병합하는 과정에서 추가 메모리를 사용하기 때문에 \(O(n)\)의 공간이 필요합니다.

---

### 병합 정렬의 특징

1. **안정 정렬**: 병합 정렬은 동일한 값을 가진 요소의 상대적 순서를 유지하는 안정 정렬입니다.
2. **일관된 성능**: 최선, 평균, 최악의 경우 모두 \(O(n \log n)\)의 시간 복잡도를 가지므로 안정적인 성능을 보장합니다.
3. **추가 메모리 필요**: 병합하는 과정에서 추가적인 배열이 필요하므로 공간 효율성이 떨어질 수 있습니다.
4. **데이터 구조의 유연성**: 연결 리스트와 같은 구조에서도 효율적으로 사용할 수 있습니다.

병합 정렬은 **안정성**이 중요하거나, **일관된 성능 보장**이 필요한 경우에 유리합니다.