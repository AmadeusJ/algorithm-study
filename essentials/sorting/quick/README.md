퀵 정렬(Quick Sort)은 **분할 정복(Divide and Conquer)** 방법을 사용하여 리스트를 정렬하는 효율적인 알고리즘 중 하나입니다. **기준(pivot)**이 되는 요소를 정해, 리스트를 기준보다 작은 요소와 큰 요소로 나눈 뒤 각각을 재귀적으로 정렬해 나가는 방식입니다. 

퀵 정렬은 평균적으로 매우 빠르며, 대부분의 경우 \(O(n \log n)\)의 시간 복잡도를 가지지만, 특정 경우에 \(O(n^2)\)의 최악 시간 복잡도를 가질 수 있습니다. 

---

### 퀵 정렬의 동작 방식

퀵 정렬은 다음과 같은 단계로 이루어집니다:

1. **기준(Pivot) 선택**: 리스트에서 기준이 될 요소를 선택합니다. 일반적으로 리스트의 첫 번째 요소, 마지막 요소, 중앙 요소, 또는 랜덤 요소를 선택합니다.
2. **분할(Divide)**: 리스트를 기준보다 작은 부분과 큰 부분으로 나눕니다. 
   - 기준보다 작은 요소는 왼쪽으로, 큰 요소는 오른쪽으로 이동시키는 방식입니다.
3. **재귀 호출**: 기준을 제외한 왼쪽 부분과 오른쪽 부분에 대해 각각 퀵 정렬을 재귀적으로 수행합니다.
4. **병합(Merge)**: 모든 재귀 호출이 완료되면 부분 리스트들이 정렬된 상태로 결합됩니다.

이 과정은 리스트가 더 이상 나눌 수 없을 때까지(부분 리스트의 크기가 1 이하일 때까지) 재귀적으로 반복됩니다.

---


### 퀵 정렬의 과정 예시

리스트 `[5, 3, 8, 4, 2, 7, 1, 10]`을 퀵 정렬로 정렬하는 과정을 살펴보겠습니다.

1. **첫 번째 재귀 호출**:
   - 기준은 `10`입니다.
   - 기준보다 작은 요소: `[5, 3, 8, 4, 2, 7, 1]`
   - 기준보다 큰 요소: 없음
   - 부분 리스트 `[5, 3, 8, 4, 2, 7, 1]`에 대해 재귀 호출을 수행합니다.

2. **두 번째 재귀 호출** (`[5, 3, 8, 4, 2, 7, 1]`):
   - 기준은 `1`입니다.
   - 기준보다 작은 요소: 없음
   - 기준보다 큰 요소: `[5, 3, 8, 4, 2, 7]`
   - 부분 리스트 `[5, 3, 8, 4, 2, 7]`에 대해 재귀 호출을 수행합니다.

3. **세 번째 재귀 호출** (`[5, 3, 8, 4, 2, 7]`):
   - 기준은 `7`입니다.
   - 기준보다 작은 요소: `[5, 3, 4, 2]`
   - 기준보다 큰 요소: `[8]`
   - 부분 리스트 `[5, 3, 4, 2]`에 대해 재귀 호출을 수행합니다.

이 과정을 반복하면 최종적으로 리스트는 `[1, 2, 3, 4, 5, 7, 8, 10]`으로 정렬됩니다.

---

### 퀵 정렬의 시간 복잡도

- **평균 시간 복잡도**: \(O(n \log n)\)
- **최악 시간 복잡도**: \(O(n^2)\) (이미 정렬된 리스트에서, 첫 번째 또는 마지막 요소를 기준으로 선택할 때 발생할 수 있습니다)
- **최선 시간 복잡도**: \(O(n \log n)\)

### 퀵 정렬의 특징

- **효율성**: 대부분의 경우 매우 빠르게 동작하며, 평균적으로 \(O(n \log n)\)의 성능을 가집니다.
- **불안정 정렬**: 동일한 값이 있는 경우, 값의 상대적인 위치가 유지되지 않습니다.
- **제자리 정렬**: 추가적인 메모리 사용이 적은 제자리 정렬로 구현할 수 있습니다(파티션을 이용하는 방식).

퀵 정렬은 성능이 우수하여 실제로 많이 사용되지만, 최악의 경우를 피하기 위해 **기준을 무작위로 선택**하는 등의 방식을 추가할 수 있습니다.