BFS(Breadth-First Search, 너비 우선 탐색)는 **그래프 탐색 알고리즘** 중 하나로, 시작 노드에서 가까운 노드부터 순차적으로 탐색하는 방식입니다. BFS는 **큐(Queue)** 자료 구조를 사용하여 구현하며, **최단 경로 탐색** 및 **레벨 순회**에 적합한 알고리즘입니다.

---

### BFS의 동작 방식

1. **시작 노드 방문**:
   - 탐색을 시작할 노드를 방문하고 큐에 추가합니다.

2. **큐에서 노드 꺼내기**:
   - 큐의 맨 앞에 있는 노드를 꺼냅니다.

3. **인접 노드 방문**:
   - 꺼낸 노드의 인접 노드 중 방문하지 않은 노드를 큐에 추가하고, 방문 표시를 합니다.

4. **반복**:
   - 큐가 빌 때까지 위 과정을 반복합니다.

---

### BFS의 특징

1. **탐색 순서**:
   - 가까운 노드(레벨이 낮은 노드)를 먼저 탐색합니다.
   - 동일한 레벨의 노드는 삽입된 순서대로 탐색됩니다.

2. **자료 구조**:
   - 큐(Queue)를 사용하여 탐색 순서를 관리합니다.

3. **최단 경로**:
   - 간선의 가중치가 모두 동일한 경우, BFS는 시작 노드에서 목표 노드까지의 최단 경로를 찾을 수 있습니다.

4. **방문 여부 관리**:
   - 방문 여부를 기록하기 위해 `visited` 리스트 또는 딕셔너리를 사용합니다.

---

### BFS의 구현 방법

#### 코드 예시: BFS 구현

다음은 인접 리스트를 사용하여 BFS를 구현한 코드입니다.

```python
from collections import deque

def bfs(graph, start):
    visited = [False] * len(graph)  # 방문 여부를 기록하는 리스트
    queue = deque([start])  # 시작 노드를 큐에 추가
    visited[start] = True  # 시작 노드를 방문 처리
    
    while queue:
        node = queue.popleft()  # 큐의 맨 앞에서 노드를 꺼냄
        print(node, end=" ")  # 방문한 노드 출력 (예시)

        for neighbor in graph[node]:
            if not visited[neighbor]:  # 인접 노드 중 방문하지 않은 노드를 탐색
                queue.append(neighbor)  # 큐에 추가
                visited[neighbor] = True  # 방문 처리
```

---

### BFS의 동작 과정

다음 그래프를 BFS로 탐색한다고 가정하겠습니다.

#### 예시 그래프:
```plaintext
graph = {
    0: [1, 2],
    1: [0, 3, 4],
    2: [0, 5, 6],
    3: [1],
    4: [1],
    5: [2],
    6: [2]
}
```

#### BFS 탐색 순서:

1. 시작 노드를 `0`으로 설정.
2. 큐의 상태와 방문 순서를 기록하며 진행.

```plaintext
1. 큐: [0], 방문: [0]
2. 큐: [1, 2], 방문: [0, 1, 2]
3. 큐: [2, 3, 4], 방문: [0, 1, 2, 3, 4]
4. 큐: [3, 4, 5, 6], 방문: [0, 1, 2, 3, 4, 5, 6]
5. 큐: [4, 5, 6], 방문: [0, 1, 2, 3, 4, 5, 6]
6. 큐: [5, 6], 방문: [0, 1, 2, 3, 4, 5, 6]
7. 큐: [6], 방문: [0, 1, 2, 3, 4, 5, 6]
8. 큐: [], 방문 완료: [0, 1, 2, 3, 4, 5, 6]
```

출력: `0 → 1 → 2 → 3 → 4 → 5 → 6`

---

### BFS의 시간 복잡도

- **시간 복잡도**: \(O(V + E)\)
  - \(V\): 그래프의 노드 개수
  - \(E\): 그래프의 간선 개수
  - 모든 노드와 간선을 한 번씩 탐색하므로 \(O(V + E)\)입니다.

- **공간 복잡도**: \(O(V)\)
  - 방문 리스트와 큐를 저장하기 위한 공간이 필요합니다.

---

### BFS의 활용

1. **최단 경로 찾기**:
   - 가중치가 없는 그래프에서 시작 노드부터 목표 노드까지의 최단 경로를 찾을 때 사용됩니다.
   
2. **레벨 탐색**:
   - 트리 구조에서 특정 깊이에 있는 노드를 탐색하거나, 노드의 레벨을 확인하는 데 유용합니다.

3. **그래프의 연결 요소 확인**:
   - 연결 요소를 확인하거나, 연결된 컴포넌트의 개수를 세는 문제에 사용됩니다.

4. **전염/확산 문제**:
   - 바이러스 전파, 네트워크 확산 등의 문제에서 각 노드가 전염되는 시간을 계산하는 데 유용합니다.

---

### BFS와 DFS의 비교

| **특징**             | **BFS**                          | **DFS**                          |
|-----------------------|-----------------------------------|-----------------------------------|
| **탐색 순서**         | 가까운 노드(레벨 순)              | 깊은 노드부터                     |
| **자료 구조**         | 큐                                | 스택 (재귀 호출로도 구현 가능)   |
| **최단 경로 보장**    | 보장 (가중치가 없는 경우)         | 보장하지 않음                     |
| **메모리 사용량**     | 넓은 그래프에서는 더 많이 사용    | 깊은 그래프에서는 더 많이 사용    |
| **적합한 문제 유형**  | 최단 경로, 레벨 탐색              | 모든 경로 탐색, 백트래킹          |

---

### BFS 요약

BFS는 **레벨별 탐색**, **최단 경로 찾기**, **확산 문제** 등에 적합하며, 큐를 이용해 구현됩니다. 노드와 간선의 수에 따라 시간 복잡도가 \(O(V + E)\)로, 효율적이고 안정적인 탐색 알고리즘입니다. DFS와의 차이점을 이해하고, 문제의 특성에 따라 적절히 선택하는 것이 중요합니다.